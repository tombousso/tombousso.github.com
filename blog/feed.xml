<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://tombousso.com/blog</link>
    <atom:link href="https://tombousso.com/blog/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Thu, 16 Nov 2017 11:35:07 -0800</pubDate>
    <lastBuildDate>Thu, 16 Nov 2017 11:35:07 -0800</lastBuildDate>

    <item>
      <title>Limits in the JVM</title>
      <link>https://tombousso.com/blog/limits-in-jvm.html</link>
      <pubDate>Sun, 5 Nov 2017 00:00:00 -0700</pubDate>
      <guid isPermaLink="false">limits-in-jvm.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Scattered throughout &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;chapter 4 of the JVM spec&lt;/a&gt; are the various structs which make up a classfile. In these structs are entries like &lt;code&gt;u2 fields_count&lt;/code&gt; and &lt;code&gt;u2 methods_count&lt;/code&gt;, which limit both the number of fields declared in a class and the number of methods declared in a class to 65535.
Code attributes have &lt;code&gt;u4 code_length&lt;/code&gt;, and so you might expect that a method can have 2^32-1 bytecodes, but the limit is actually 65535:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
The value of code_length must be greater than zero (as the code array must not be empty) and less than 65536.
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3&quot; class=&quot;bare&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.3&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While humans probably won&amp;#8217;t surpass these limits while writing Java code, classfiles are often generated by automated tools or from languages other than Java, and 64K of bytecodes is not a huge amount. The &lt;code&gt;code_length&lt;/code&gt;, &lt;code&gt;fields_count&lt;/code&gt;, and &lt;code&gt;methods_count&lt;/code&gt; limits should be increased (to either 32-bit, 64-bit, or varint), however increasing them requires a significant number of changes to the JVM spec.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Dijkstra&apos;s Algorithm in Java</title>
      <link>https://tombousso.com/blog/dijkstras-algorithm-java.html</link>
      <pubDate>Thu, 26 Oct 2017 00:00:00 -0700</pubDate>
      <guid isPermaLink="false">dijkstras-algorithm-java.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Wrote an implementation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm&quot;&gt;Dijkstra&amp;#8217;s algorithm&lt;/a&gt; in Java using a PriorityQueue. The code is quite simple (only 50 lines):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;!-- more --&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import java.util.*;
class Graph {
	Map&amp;lt;Integer, Set&amp;lt;Edge&amp;gt;&amp;gt; edges = new HashMap&amp;lt;&amp;gt;(); // node to edges
	Map&amp;lt;Integer, Integer&amp;gt; dists; // node to distance

	void addVertex(int i) {
		edges.put(i, new HashSet&amp;lt;&amp;gt;());
	}

	void addEdge(int src, int dst, int w) {
		edges.get(src).add(new Edge(src, dst, w));
	}

	void addUndirectedEdge(int src, int dst, int w) {
		addEdge(src, dst, w);
		addEdge(dst, src, w);
	}

	Map&amp;lt;Integer, Integer&amp;gt; getDistancesFrom(int iStart) {
		dists = new HashMap&amp;lt;&amp;gt;();
		dists.put(iStart, 0);
		PriorityQueue&amp;lt;Edge&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;();
		pq.addAll(edges.get(iStart));
		while (!pq.isEmpty()) {
			Edge e = pq.poll();
			if (!dists.containsKey(e.dst)) {
				dists.put(e.dst, e.dist());
				pq.addAll(edges.get(e.dst));
			}
		}
		return dists;
	}

	class Edge implements Comparable&amp;lt;Edge&amp;gt; {
		int src;
		int dst;
		int w;

		public Edge(int src, int dst, int w) {
			this.src = src;
			this.dst = dst;
			this.w = w;
		}

		public int compareTo(Edge e) {
			return Integer.compare(this.dist(), e.dist());
		}

		int dist() {
			return dists.get(src) + w;
		}
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This code is O(|E| log |E|) because it stores edges in the heap rather than vertices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And a simple test case:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Graph g = new Graph();
g.addVertex(1);
g.addVertex(2);
g.addVertex(3);
g.addEdge(1, 2, 5);
g.addEdge(2, 3, 15);
g.addEdge(1, 3, 21);
System.out.println(g.getDistancesFrom(1).get(3));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This will print 20, the shortest distance between vertex 1 and vertex 3.&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Unexpected JVM Behavior</title>
      <link>https://tombousso.com/blog/unexpected-jvm-behavior.html</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 -0700</pubDate>
      <guid isPermaLink="false">unexpected-jvm-behavior.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Here&amp;#8217;s a disassembled classfile (&lt;code&gt;Test.class&lt;/code&gt;):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;Classfile format major version: 50, minor version: 0.
Access flags: public super
Field name: x Signature: static int
Method name: &quot;&amp;lt;clinit&amp;gt;&quot; Signature: ()void
  0: iconst_1
  1: putstatic &amp;lt;Field Test.x int&amp;gt;
  4: return
Method name: &quot;main&quot; Signature: public static (java.lang.String[])void
  0: getstatic &amp;lt;Field java.lang.System.out java.io.PrintStream&amp;gt;
  3: getstatic &amp;lt;Field Test.x int&amp;gt;
  6: invokevirtual &amp;lt;Method java.io.PrintStream.println (int)void&amp;gt;
  9: return&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This classfile &lt;em&gt;roughly&lt;/em&gt; corresponds to the following Java code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class Test {
	static int x;
	static {
		x = 1;
	}
	public static void main(String[] args) {
		System.out.println(x);
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So what happens when we run this classfile? The main method prints &lt;code&gt;1&lt;/code&gt;, as we would expect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However&amp;#8230;&amp;#8203; if we change the classfile format major version from 50 (Java 1.6) to 51 (Java 1.7)&amp;#8230;&amp;#8203; then the main method prints &lt;code&gt;0&lt;/code&gt;! The JVM doesn&amp;#8217;t run the &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you look back at the disassembled classfile, you might notice that the &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; method is not static (that is, it doesn&amp;#8217;t have the &lt;code&gt;ACC_STATIC&lt;/code&gt; flag set). Surprisingly, JVM version 1.6 didn&amp;#8217;t care whether or not &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; methods are defined as static. When this issue was reported in 2009, the fix was to disallow non-static &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; methods when the classfile major version is greater than 50 (for backwards compatibility). I ran into this quirk while working on &lt;a href=&quot;https://github.com/tombousso/sJava&quot;&gt;sJava&lt;/a&gt;, but as usual reading the JVM Specification would have saved me some trouble:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
In a class file whose version number is 51.0 or above, the method [&amp;lt;clinit&amp;gt;] must additionally have its ACC_STATIC flag (ยง4.6) set in order to be the class or interface initialization method.
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9&quot; class=&quot;bare&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
